"""
CloudSentinel - CloudTrail Processor
Processes REAL CloudTrail logs from S3 and feeds suspicious events
into the detection pipeline (same DynamoDB table as simulators).

Triggered by S3 ObjectCreated events when CloudTrail writes new log files.
"""
import gzip
import json
import os
import urllib.parse

import boto3

from shared.utils import create_security_event, MITRE

s3_client = boto3.client("s3")

# ── Suspicious patterns to detect ───────────────────────────────

# IAM actions that indicate privilege escalation
PRIV_ESC_ACTIONS = {
    "AttachUserPolicy", "AttachGroupPolicy", "AttachRolePolicy",
    "PutUserPolicy", "PutGroupPolicy", "PutRolePolicy",
    "CreatePolicyVersion", "SetDefaultPolicyVersion",
    "AddUserToGroup", "CreateLoginProfile", "UpdateLoginProfile",
    "CreateAccessKey", "UpdateAssumeRolePolicy",
}

# Actions that indicate data exfiltration
EXFIL_ACTIONS = {
    "PutBucketPolicy", "PutBucketAcl", "PutObjectAcl",
    "DeleteBucketPolicy", "PutBucketPublicAccessBlock",
}

# Actions that indicate reconnaissance
RECON_ACTIONS = {
    "ListBuckets", "ListUsers", "ListRoles", "ListPolicies",
    "GetAccountAuthorizationDetails", "ListAccessKeys",
    "DescribeInstances", "DescribeSecurityGroups",
    "ListSecrets", "DescribeDBInstances",
}

# Actions that indicate persistence
PERSISTENCE_ACTIONS = {
    "CreateUser", "CreateRole", "CreateAccessKey",
    "CreateLoginProfile", "AuthorizeSecurityGroupIngress",
}

# Console login events
LOGIN_EVENTS = {"ConsoleLogin"}

# Services to ignore (CloudSentinel's own activity + noisy services)
IGNORED_USER_AGENTS = {
    "cloudformation.amazonaws.com",
    "lambda.amazonaws.com",
    "elasticmapreduce.amazonaws.com",
}

# Our own resources to ignore
SENTINEL_PREFIX = "cloudsentinel"


def is_own_activity(event: dict) -> bool:
    """Check if this event was generated by CloudSentinel itself."""
    user_agent = event.get("userAgent", "")
    source_name = event.get("eventSource", "")

    # Ignore Lambda execution role activity
    user_identity = event.get("userIdentity", {})
    arn = user_identity.get("arn", "")
    if SENTINEL_PREFIX in arn.lower():
        return True

    # Ignore CloudFormation deploying our stack
    if "cloudformation" in user_agent.lower():
        return True

    return False


def classify_event(ct_event: dict) -> dict | None:
    """
    Analyze a CloudTrail event and classify it as a security event.
    Returns None if the event is benign or should be ignored.
    """
    event_name = ct_event.get("eventName", "")
    event_source = ct_event.get("eventSource", "")
    error_code = ct_event.get("errorCode", "")
    user_identity = ct_event.get("userIdentity", {})
    source_ip = ct_event.get("sourceIPAddress", "unknown")
    user_arn = user_identity.get("arn", "unknown")
    user_type = user_identity.get("type", "unknown")
    user_name = user_identity.get("userName", user_arn)

    # Skip our own activity
    if is_own_activity(ct_event):
        return None

    # ── Failed console login ──────────────────────────────────
    if event_name == "ConsoleLogin":
        response = ct_event.get("responseElements", {})
        login_result = response.get("ConsoleLogin", "")

        if login_result == "Failure":
            return {
                "event_type": "BRUTE_FORCE",
                "source_ip": source_ip,
                "user_identity": user_name,
                "action": "ConsoleLogin",
                "resource": f"arn:aws:iam::account:user/{user_name}",
                "outcome": "failure",
                "severity": "MEDIUM",
                "mitre_tactic": MITRE["brute_force"]["tactic"],
                "mitre_technique": MITRE["brute_force"]["technique"],
                "details": {
                    "source": "cloudtrail_real",
                    "event_name": event_name,
                    "error_code": error_code,
                    "mfa_used": ct_event.get("additionalEventData", {}).get("MFAUsed", "Unknown"),
                    "user_agent": ct_event.get("userAgent", ""),
                },
            }

        # Successful login from unusual source
        if login_result == "Success":
            return {
                "event_type": "BRUTE_FORCE",
                "source_ip": source_ip,
                "user_identity": user_name,
                "action": "ConsoleLogin",
                "resource": f"arn:aws:iam::account:user/{user_name}",
                "outcome": "success",
                "severity": "LOW",
                "mitre_tactic": MITRE["brute_force"]["tactic"],
                "mitre_technique": MITRE["brute_force"]["technique"],
                "details": {
                    "source": "cloudtrail_real",
                    "event_name": event_name,
                    "mfa_used": ct_event.get("additionalEventData", {}).get("MFAUsed", "Unknown"),
                    "user_agent": ct_event.get("userAgent", ""),
                    "note": "Successful login tracked for correlation",
                },
            }

    # ── Privilege escalation actions ──────────────────────────
    if event_name in PRIV_ESC_ACTIONS:
        severity = "CRITICAL" if "Admin" in json.dumps(ct_event.get("requestParameters", {})) else "HIGH"

        return {
            "event_type": "PRIVILEGE_ESCALATION",
            "source_ip": source_ip,
            "user_identity": user_name,
            "action": f"{event_source.split('.')[0]}:{event_name}",
            "resource": user_arn,
            "outcome": "failure" if error_code else "success",
            "severity": severity,
            "mitre_tactic": MITRE["privilege_escalation"]["tactic"],
            "mitre_technique": MITRE["privilege_escalation"]["technique"],
            "details": {
                "source": "cloudtrail_real",
                "event_name": event_name,
                "event_source": event_source,
                "request_parameters": _safe_truncate(ct_event.get("requestParameters", {})),
                "error_code": error_code,
                "error_message": ct_event.get("errorMessage", ""),
            },
        }

    # ── Data exfiltration indicators ──────────────────────────
    if event_name in EXFIL_ACTIONS:
        return {
            "event_type": "DATA_EXFILTRATION",
            "source_ip": source_ip,
            "user_identity": user_name,
            "action": f"{event_source.split('.')[0]}:{event_name}",
            "resource": _extract_resource(ct_event),
            "outcome": "failure" if error_code else "success",
            "severity": "CRITICAL" if event_name in ("PutBucketPolicy", "DeleteBucketPolicy") else "HIGH",
            "mitre_tactic": MITRE["data_exfiltration"]["tactic"],
            "mitre_technique": MITRE["data_exfiltration"]["technique"],
            "details": {
                "source": "cloudtrail_real",
                "event_name": event_name,
                "event_source": event_source,
                "request_parameters": _safe_truncate(ct_event.get("requestParameters", {})),
                "error_code": error_code,
            },
        }

    # ── Persistence mechanisms ────────────────────────────────
    if event_name in PERSISTENCE_ACTIONS:
        return {
            "event_type": "PRIVILEGE_ESCALATION",
            "source_ip": source_ip,
            "user_identity": user_name,
            "action": f"{event_source.split('.')[0]}:{event_name}",
            "resource": _extract_resource(ct_event),
            "outcome": "failure" if error_code else "success",
            "severity": "HIGH",
            "mitre_tactic": MITRE["iam_manipulation"]["tactic"],
            "mitre_technique": MITRE["iam_manipulation"]["technique"],
            "details": {
                "source": "cloudtrail_real",
                "event_name": event_name,
                "event_source": event_source,
                "request_parameters": _safe_truncate(ct_event.get("requestParameters", {})),
                "error_code": error_code,
                "note": "Potential persistence mechanism",
            },
        }

    # ── AccessDenied errors (someone poking around) ───────────
    if error_code in ("AccessDenied", "UnauthorizedAccess", "Client.UnauthorizedAccess"):
        return {
            "event_type": "LATERAL_MOVEMENT",
            "source_ip": source_ip,
            "user_identity": user_name,
            "action": f"{event_source.split('.')[0]}:{event_name}",
            "resource": _extract_resource(ct_event),
            "outcome": "failure",
            "severity": "MEDIUM",
            "mitre_tactic": MITRE["lateral_movement"]["tactic"],
            "mitre_technique": MITRE["lateral_movement"]["technique"],
            "details": {
                "source": "cloudtrail_real",
                "event_name": event_name,
                "event_source": event_source,
                "error_code": error_code,
                "error_message": ct_event.get("errorMessage", ""),
                "note": "Unauthorized access attempt",
            },
        }

    # ── AssumeRole from unusual patterns ──────────────────────
    if event_name == "AssumeRole" and not error_code:
        # Track all role assumptions for correlation
        request_params = ct_event.get("requestParameters", {})
        role_arn = request_params.get("roleArn", "unknown")

        return {
            "event_type": "LATERAL_MOVEMENT",
            "source_ip": source_ip,
            "user_identity": user_name,
            "action": "sts:AssumeRole",
            "resource": role_arn,
            "outcome": "success",
            "severity": "LOW",
            "mitre_tactic": MITRE["lateral_movement"]["tactic"],
            "mitre_technique": MITRE["lateral_movement"]["technique"],
            "details": {
                "source": "cloudtrail_real",
                "event_name": event_name,
                "assumed_role": role_arn,
                "session_duration": request_params.get("durationSeconds", "default"),
                "note": "Role assumption tracked for correlation",
            },
        }

    return None


def _extract_resource(ct_event: dict) -> str:
    """Extract the target resource ARN from a CloudTrail event."""
    resources = ct_event.get("resources", [])
    if resources:
        return resources[0].get("ARN", "unknown")

    params = ct_event.get("requestParameters", {})
    if params:
        for key in ("bucketName", "userName", "roleName", "policyArn", "groupName"):
            if key in params:
                return str(params[key])

    return "unknown"


def _safe_truncate(obj: dict, max_length: int = 500) -> dict:
    """Truncate request parameters to avoid DynamoDB item size limits."""
    text = json.dumps(obj, default=str)
    if len(text) > max_length:
        return {"truncated": text[:max_length] + "..."}
    return obj


# ── Lambda Handler ───────────────────────────────────────────────

def handler(event, context):
    """
    Triggered by EventBridge with CloudTrail events directly.
    Format: {"detail-type": "AWS API Call via CloudTrail", "detail": {CloudTrail event}}
    """
    processed = 0
    security_events = 0

    # EventBridge sends one CloudTrail event at a time in "detail"
    if "detail" in event and "eventName" in event.get("detail", {}):
        ct_event = event["detail"]
        processed = 1

        classified = classify_event(ct_event)
        if classified:
            create_security_event(**classified)
            security_events = 1
            print(
                f"[TrailProcessor] REAL event detected: {ct_event.get('eventName')} "
                f"by {ct_event.get('userIdentity', {}).get('arn', 'unknown')} "
                f"-> {classified['event_type']} ({classified['severity']})"
            )

    print(f"[TrailProcessor] Processed {processed}, created {security_events} security events")

    return {
        "statusCode": 200,
        "cloudtrail_events_processed": processed,
        "security_events_created": security_events,
    }
